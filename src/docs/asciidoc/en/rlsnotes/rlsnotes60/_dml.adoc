[#rnfb60-dml]
= Data Manipulation Language (DML)

[#rnfb60-dml-links]
.Quick Links
* <<rnfb60-dml-routine-call-default>>
* <<rnfb60-dml-named-args>>
* <<rnfb60-dml-call-stmt>>
* <<rnfb60-dml-built-in-functions>>
** <<rnfb60-dml-any-value>>
** ...

////
Generic template:

[#rnfb60-dml-<abbreviated-subject>]
== <subject>
<implementer/author>

Tracker ticket: https://github.com/FirebirdSQL/firebird/[pull/]<issue>[#<issue>]

<short description>

.Syntax
[listing]
----
<syntax>
----

[<more details>]

.Examples
[listing]
----
<examples>
----

////

[#rnfb60-dml-routine-call-default]
== Allow `DEFAULT` Keyword in Argument List
Adriano dos Santos Fernandes

Tracker ticket: https://github.com/FirebirdSQL/firebird/issues/7566[#7566]

The keyword `DEFAULT` can now be used in an argument list of a function or procedure call to explicitly use its default value (or that of its domain).
If the parameter or its domain has no default, the actual argument value is `NULL`.

.Example
[listing]
----
select function_name(1, DEFAULT, DEFAULT, 'Something')
from rdb$database;
----

[#rnfb60-dml-named-args]
== Named Arguments for Function and Procedure Calls
Adriano dos Santos Fernandes

Tracker ticket: https://github.com/FirebirdSQL/firebird/issues/7586[#7586]

Named arguments allows you to specify function and procedure arguments by name, rather than by position.

This is especially useful when a routine has a lot of parameters, you want to specify arguments in a different order, or not specify those with default values.

.Syntax
[listing,subs=+quotes]
----
<function call> ::=
  [_schema_ .] [_package_ .] _function_ ( [<arguments>] )

<procedure selection> ::=
  [_schema_ .] [_package_ .]  _procedure_ [( <arguments> )]

<execute procedure> ::=
  EXECUTE PROCEDURE [_schema_ .] [_package_ .] _procedure_
    [ (<arguments>) | <arguments> ]
    [RETURNING_VALUES ...]

<arguments> ::=
    <positional arguments>
  | [ <positional arguments> , ] <named arguments>

<positional arguments> ::=
  <value> [ { , <value> }... ]

<named arguments> ::=
  <named argument> [ { , <named argument> }... ]

<named argument> ::=
  _argument-name_ => <value>
----

Like the positional syntax, all arguments without default values are required.

A call can use positional, named, or mixed arguments.
In mixed syntax, positional arguments must appear before named arguments.

.Examples
[listing]
----
select function_name(parameter2 => 'Two', parameter1 => 1)
from rdb$database;

select function_name(1, parameter2 => 'Two')
from rdb$database;

execute procedure insert_customer(
  last_name => 'SCHUMACHER',
  first_name => 'MICHAEL');

select *
from get_customers(city_id => 10, last_name => 'SCHUMACHER');
----

[#rnfb60-dml-call-stmt]
== `CALL` Statement for Executing Procedures
Adriano dos Santos Fernandes

Tracker ticket: https://github.com/FirebirdSQL/firebird/issues/7587[#7587]

The `CALL` statement is similar to `EXECUTE PROCEDURE`, but allows the caller to only get specific output parameters, or none.

.Syntax
[listing,subs=+quotes]
----
CALL [ _schema_ . ] [ _package_ .] _procedure_ (<arguments>)

<arguments> ::=
    <positional arguments> |
    [ <positional arguments> , ] <named arguments>

<positional arguments> ::=
    <value or default> [ { , <value or default> }... ]

<named arguments> ::=
    <named argument> [ { , <named argument> }... ]

<named argument> ::=
    _argument-name_ => <value or default>

<value or default> ::= <value> | DEFAULT
----

When using positional arguments, output parameters follow after the input parameters.

In DSQL, output parameters are specified using `?`.
In PSQL, using the names of the target variables.

To exclude an output parameter as a positional argument, pass `NULL`, or only reference the desired output parameters using named argument syntax.

When used with selectable stored procedures, only the first row is returned, and the stored procedure exits after the first `SUSPEND`.
This is the same behaviour as with `EXECUTE PROCEDURE`.

.Examples
[source]
----
set term #;
create or alter procedure insert_customer (
  last_name varchar(30),
  first_name varchar(30))
returns (
  id integer,
  full_name varchar(62))
as
begin
  insert into customers (last_name, first_name)
    values (:last_name, :first_name)
    returning id, last_name || ', ' || first_name
    into :id, :full_name;
end#
set term ;#

-- Not all output parameters are necessary.
call insert_customer(
  'LECLERC',
  'CHARLES',
  ?);

-- Ignore first output parameter (using NULL) and get the second.
call insert_customer(
  'LECLERC',
  'CHARLES',
  null,
  ?);

-- Ignore ID output parameter.
call insert_customer(
  'LECLERC',
  'CHARLES',
  full_name => ?);

-- Pass inputs and get outputs using named arguments.
call insert_customer(
  last_name => 'LECLERC',
  first_name => 'CHARLES',
  last_name => ?,
  id => ?);

set term #;
create or alter procedure do_something_and_insert_customer returns (
  out_id integer,
  out_full_name varchar(62))
as
  declare last_name varchar(30);
  declare first_name varchar(30);
begin
  call insert_customer(
    last_name,
    first_name,
    out_id,
    full_name => out_full_name);
end#
set term ;#
----

[#rnfb60-dml-built-in-functions]
== New Expressions and Built-in Functions

[#rnfb60-dml-any-value]
=== `ANY_VALUE` Aggregate Function
Adriano dos Santos Fernandes

Tracker ticket: https://github.com/FirebirdSQL/firebird/pull/7617[#7617]

`ANY_VALUE` is a SQL:2023 non-deterministic aggregate function that returns the result of an expression applied to an arbitrary row in the group.

.Syntax
[listing]
----
ANY_VALUE ( <expr> )
----

This function only returns `NULL` if there is no row in the group where _expr_ produces a non-``NULL`` result.

.Example
[listing]
----
select
  DEPT_NO,
  any_value(FIRST_NAME || ' ' || LAST_NAME) "Example Employee"
from EMPLOYEE
group by DEPT_NO
----